<?php


namespace wfm;

use RedBeanPHP\R;
use Valitron\Validator;

abstract class Model
{ // Создаем базовый абстрактный класс модели (нельзя создавать объекты, можно только наследоваться)

    public array $attributes = []; // Свойство, Это свойство нужно для автозаполнения модели данными, когда данные приходят, например, из форм от пользователя, мы можем взять только те данные безопасным способом, которые нам нужны. Это мы укажем в массиве "attributes"
    public array $errors = []; // Свойство, Сюда мы будем складывать возможные ошибки, которые будут получены, например, при валидации данных пользователей
    public array $rules = []; // Свойство, Массив правил валидации для проверки правильности и корректности данных, отправляемых пользователем через форму на сайте
    public array $labels = []; // Свойство нам нужно, чтобы указывать какое именно поле не прошло валидацию. В первую очередь, чтобы реализовать мультиязычность - мы в него запишем переводные фразы для отображения пользователю

    public function __construct()
    { // Получим объект подключения к БД
        Db::getInstance();
    }

    public function load($post = true)
    { // Метод, который будет загружать только те переданные пользователем данные (основываясь на аттрибутах $attributes), которые нам нужны для работы данной модели. На вход принимает массив данных $post, если false - значит мы берем данные из массива $_GET

        $data = $post ? $_POST : $_GET; // Записываем в переменную $data: если $post true - тогда мы берем данные из массива $_POST. Иначе - берем данные из массива $_GET

        foreach ($this->attributes as $name => $value) { // Будет проходиться в цикле по аттрибутам
            if (isset($data[$name])) { // Если в полученном массиве данных $data есть данные с ключом $name
                $this->attributes[$name] = $data[$name]; // Заполняем аттрибуты по ключу $name теми значениями, которые к нам пришли
            }
        }
    }

    public function validate($data): bool
    { // Метод валидации данных, пришедших от пользователя после заполнения и отправки формы на сайте. Принимает аргументом массив данных от пользователя $data
        Validator::langDir(APP . '/languages/validator/lang'); // Подключаем папку с языковыми файлами валидатору Validator
        Validator::lang(App::$app->getProperty ('language')['code']); // Указываем язык для переводного файла
        $validator = new Validator($data); // Создаем объект класса Validator (класс подключенной библиотеки валидации Valitron). На вход передаем данные пользователя $data
        $validator->rules($this->rules); // Передаем методом валидатора rules массив правил свойства rules
        $validator->labels($this->getLabels()); // Чтобы валидатор $validator использовал наши лейблы labels, мы должны ему указать с помощью специального метода labels наши переводные фразы с помощью метода getLabels. Вернем массив, где ключом будет имя поля, а значением наша переводная фраза
        if ($validator->validate()) { // Проверяем результат валидации данных пользователя
            return true; // Если все Ок
        } else { // Иначе
            $this->errors = $validator->errors(); // Получаем ошибки при валидации используя $validator и метод errors
            /*debug ($this->errors); // Проверка правильности выполнения*/
            return false;
        }
    }

    public function getErrors()
    { // Метод, который будет собирать и показывать ошибки при отправке данных пользователем
        $errors = '<ul>'; // Создаем переменную $errors для показа списка ошибок
        foreach ($this->errors as $error) { // Проходим в цикле по массиву ошибок валидации, который представит нам validator
            foreach ($error as $item) { // Проходим в цикле по вложенным массивам ошибок валидации, который представит нам validator
                $errors .= "<li>{$item}</li>"; // Здесь в переменную $errors мы будем дописывать
            }
        }
        $errors .= '</ul>'; // Закрываем список ошибок
        $_SESSION['errors'] = $errors; // Сами ошибки, мы будем записывать в сессию в массив $_SESSION из полученной переменной $errors
    }

    public function getLabels(): array
    { // Метод для получения переводных фраз для отображения пользователю сообщений об ошибках
        $labels = []; // Объявляем пустой массив $labels для заполнения данными об ошибках
        foreach ($this->labels as $k => $v) { // В цикле пройдемся по свойству $labels с разбивкой на ключ и значение
            $labels[$k] = ___($v); // В массив $labels по ключу $k мы будем возвращать соответствующее значение для переводной фразы (например: 'E-mail', 'Пароль') в зависимости от языка (русский)
        }
        return $labels; // Вернем полученный массив $labels
    }

    public function save ($table): int|string { // Метод для сохранения данных из пользовательской формы. Принимает параметром таблицу, в которой необходимо сохранить данные

        $tbl = R::dispense ($table);  // Мы создаем объект $tbl. В RedBeanPHP данные в таблицу сохраняются методом dispense. На вход передаем название таблицы в БД $table
        /*$tbl->email = ''; // Далее, мы должны создать свойство для объекта $tbl. Например, свойство email и присваиваем ему какое-либо значение.
        $tbl->name = '';*/

        foreach ($this->attributes as $name => $value) { // Альтернативный вариант используя свойство $attributes модели User.
            if ($value != '') { // Если у нас значение не пусто
                $tbl->$name = $value; // Указываем для объекта $tbl свойства с соответствующими значениями. При прохождении цикла, мы будем записывать в соответствующие свойства соответсвующее значения (например: $tbl->email = '1@ru.ru' и так по каждому ключу $name из массива $attributes)
            }

        }

        return R::store ($tbl); // Сохраняем данные объекта $tbl и добавляем их в БД. Должны вернуть результаты методом store для объекта $tbl

    }

    public function update ($table, $id): int|string { // Метод для обновления учетных данных пользователя. Принимает на вход таблицу, которую нужно обновить и id записи, которую нужно обновить

        $tbl = R::load ($table, $id); // Получим запись по $id в таблице $table, которую нам нужно обновить
        foreach ($this->attributes as $name => $value ) { // Пройдемся в цикле foreach по атрибутам модели с получением массива ключ-значение
            if ($value != '') { // Если у нас переменная $value не равняется пустой строке
                $tbl->$name = $value; // Указываем для объекта $tbl свойства с соответствующими значениями. При прохождении цикла, мы будем записывать в соответствующие свойства соответсвующее значения (например: $tbl->email = '1@ru.ru' и так по каждому ключу $name из массива $attributes)
            }
        }
        return R::store ($tbl); // Сохраняем данные объекта $tbl и добавляем их в БД. Должны вернуть результаты методом store для объекта $tbl

    }

}