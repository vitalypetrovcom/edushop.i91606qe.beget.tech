<?php


namespace wfm;

use Valitron\Validator;

abstract class Model
{ // Создаем базовый абстрактный класс модели (нельзя создавать объекты, можно только наследоваться)

    public array $attributes = []; // Свойство, Это свойство нужно для автозаполнения модели данными, когда данные приходят, например, из форм от пользователя, мы можем взять только те данные безопасным способом, которые нам нужны. Это мы укажем в массиве "attributes"
    public array $errors = []; // Свойство, Сюда мы будем складывать возможные ошибки, которые будут получены, например, при валидации данных пользователей
    public array $rules = []; // Свойство, Массив правил валидации для проверки правильности и корректности данных, отправляемых пользователем через форму на сайте
    public array $labels = []; // Свойство нам нужно, чтобы указывать какое именно поле не прошло валидацию. В первую очередь, чтобы реализовать мультиязычность - мы в него запишем переводные фразы для отображения пользователю

    public function __construct()
    { // Получим объект подключения к БД
        Db::getInstance();
    }

    public function load($data)
    { // Метод, который будет загружать только те переданные пользователем данные (основываясь на аттрибутах $attributes), которые нам нужны для работы данной модели. На вход принимает массив данных $data

        foreach ($this->attributes as $name => $value) { // Будет проходиться в цикле по аттрибутам
            if (isset($data[$name])) { // Если в полученном массиве данных $data есть данные с ключом $name
                $this->attributes[$name] = $data[$name]; // Заполняем аттрибуты по ключу $name теми значениями, которые к нам пришли
            }
        }
    }

    public function validate($data): bool
    { // Метод валидации данных, пришедших от пользователя после заполнения и отправки формы на сайте. Принимает аргументом массив данных от пользователя $data
        Validator::langDir(APP . '/languages/validator/lang'); // Подключаем папку с языковыми файлами валидатору Validator
        Validator::lang('ru'); // Указываем русский язык для переводного файла
        $validator = new Validator($data); // Создаем объект класса Validator (класс подключенной библиотеки валидации Valitron). На вход передаем данные пользователя $data
        $validator->rules($this->rules); // Передаем методом валидатора rules массив правил свойства rules
        $validator->labels($this->getLabels()); // Чтобы валидатор $validator использовал наши лейблы labels, мы должны ему указать с помощью специального метода labels наши переводные фразы с помощью метода getLabels. Вернем массив, где ключом будет имя поля, а значением наша переводная фраза
        if ($validator->validate()) { // Проверяем результат валидации данных пользователя
            return true; // Если все Ок
        } else { // Иначе
            $this->errors = $validator->errors(); // Получаем ошибки при валидации используя $validator и метод errors
            /*debug ($this->errors); // Проверка правильности выполнения*/
            return false;
        }
    }

    public function getErrors()
    { // Метод, который будет собирать и показывать ошибки при отправке данных пользователем
        $errors = '<ul>'; // Создаем переменную $errors для показа списка ошибок
        foreach ($this->errors as $error) { // Проходим в цикле по массиву ошибок валидации, который представит нам validator
            foreach ($error as $item) { // Проходим в цикле по вложенным массивам ошибок валидации, который представит нам validator
                $errors .= "<li>{$item}</li>"; // Здесь в переменную $errors мы будем дописывать
            }
        }
        $errors .= '</ul>'; // Закрываем список ошибок
        $_SESSION['errors'] = $errors; // Сами ошибки, мы будем записывать в сессию в массив $_SESSION из полученной переменной $errors
    }

    public function getLabels(): array
    { // Метод для получения переводных фраз для отображения пользователю сообщений об ошибках
        $labels = []; // Объявляем пустой массив $labels для заполнения данными об ошибках
        foreach ($this->labels as $k => $v) { // В цикле пройдемся по свойству $labels с разбивкой на ключ и значение
            $labels[$k] = ___($v); // В массив $labels по ключу $k мы будем возвращать соответствующее значение для переводной фразы (например: 'E-mail', 'Пароль') в зависимости от языка (русский)
        }
        return $labels; // Вернем полученный массив $labels
    }

}