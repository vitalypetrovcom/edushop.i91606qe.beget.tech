<?php


namespace app\widgets\menu;

use RedBeanPHP\R;
use wfm\App;
use wfm\Cache;

class Menu { // Класс для работы с виджетом главного меню категорий

    // https://www.youtube.com/watch?v=fOMaYSmsiQU
    // https://www.youtube.com/watch?v=Qble3-723bs
    protected $data; // Свойство, в нем хранятся данные для нашего виджета меню (категории, которые мы будем получать из БД)
    protected $tree; // Свойство, нем будет храниться дерево, которое мы будем формировать из полученных данных
    protected $menuHtml; // Свойство, будет храниться сам html код нашего сформированного меню
    protected $tpl; // Свойство, шаблон, который будет использоваться (при необходимости, мы можем переопределить это свойство и использовать другой шаблон)
    protected $container = 'ul'; // Свойство, во что будет оборачиваться наше меню (по умолчанию это будет тег "ul", но для админки это может быть "select", "table" - в этом случае, можно использовать различные названия тега, который будет служить оберткой для нашего меню)
    protected $class = 'menu'; // Свойство, то, что по умолчанию используется в качестве класса для нашего меню, но в нашем случае, требуется другой набор классов, и мы его переопределим на 'navbar-nav ms-auto mb-2 mb-lg-0'
    /*protected $table = 'category'; // Свойство, таблица 'category' в БД где храниться наше меню (при необходимости, мы можем ее переопределить). Можно создать отдельное свойство для дополнительной таблицы при необходимости расширить данный класс*/
    protected $cache = 3600; // Свойство, кэш отвечает за кэширование нашего меню на нужное время (сек)
    protected $cacheKey = 'ishop_menu'; // Свойство, ключ (по умолчанию 'ishop_menu'), под которым данные меню будут кэшироваться
    protected $attrs = []; // Свойство, массив атрибутов, которые можно добавить к нашему меню (id, data итд)
    protected $prepend = ''; // Свойство, которое отвечает за возможный код, который можно добавить перед нашим меню (иногда это может быть полезно)
    protected $language; // Свойство, отвечает за активный язык меню для конкретного пользователя

    public function __construct($options = []){ // При инициализации данного класса, мы передаем ряд свойств, которые попадают в массив "$options" в конструкторе
        $this->language = App::$app->getProperty('language'); // Получаем активный язык из контейнера ("ру" или "англ" у нас)
        $this->tpl = __DIR__ . '/menu_tpl.php'; // Устанавливаем шаблон (по умолчанию это "menu_tpl.php", его можно переопределить (если мы передаем какие-либо опции в "$options", то это свойство будет перезаписано благодаря методу "getOptions"))
        $this->getOptions($options); // Перезаписываем опции
        $this->run(); // Метод, который делает
    }

    protected function getOptions($options){ // Метод проходит в цикле по опциям, берет ключ и значение (например: ключ(класс 'class') и значение(набор классов 'navbar-nav ms-auto mb-2 mb-lg-0'), в качестве значения ключа 'cache' попадет 30)
        foreach($options as $k => $v){
            if(property_exists($this, $k)){ // Проверяем, если существует в классе (объекте) "$this" данное свойство "$k" (есть такой ключ "$k")
                $this->$k = $v; // Тогда в это свойство запишем значение опции. Таким образом, мы заполняем введенные в начале класса свойства переданными здесь значениями

            }
        }
    }

    protected function run(){ // Метод, который делает
        $cache = Cache::getInstance(); // Создает объект кэша, чтобы, если меню у нас было закэшировано (если кэш актуален), мы возьмем меню из кэша
        $this->menuHtml = $cache->get("{$this->cacheKey}_{$this->language['code']}"); // В свойство "menuHtml", где будет храниться уже готовый код Html мы получаем данные из кэша по ключу "{$this->cacheKey}_{$this->language['code']}" с учетом выбранного пользователем языка

        if(!$this->menuHtml){ // Если мы успешно забрали данные из кэша, мы эту проверку пропустим ..
            // Если у нас "menuHtml = false" (у нас нет такого меню или оно утратило свою актуальность), мы должны заново получить меню
            $this->data = R::getAssoc("SELECT c.*, cd.* FROM category c 
                        JOIN category_description cd
                        ON c.id = cd.category_id
                        WHERE cd.language_id = ?", [$this->language['id']]); // Получаем меню из БД используя функцию RedBeanPHP - ассоациативный массив всех категорий
            $this->tree = $this->getTree(); // Получаем из массива категорий дерево методом "getTree"
            $this->menuHtml = $this->getMenuHtml($this->tree); // Из дерева нам нужно сделать только верстку методом "getMenuHtml", где будет сформирован окончательный Html код меню (в зависимости от языка и верстки, которая представлена в шаблоне "menu_tpl.php")
            if($this->cache){ // Проверяем что у нас со свойством "cache" - если значение больше 0 - нам нужно закэшировать меню методом "set"
                $cache->set("{$this->cacheKey}_{$this->language['code']}", $this->menuHtml, $this->cache); // Кладем в кэш по ключу "{$this->cacheKey}_{$this->language['code']}" строку "$this->menuHtml" на указанное количество секунд "$this->cache"
            }
        }

        $this->output(); // .. и вызовем метод "output" для вывода Html кода меню
    }

    protected function output(){ // Вызовем метод "output" для вывода Html кода меню
        $attrs = ''; // Нам нужно добавить аттрибуты к нашему меню
        if(!empty($this->attrs)){ // Проверяем, если у нас атрибуты не пустые (не пустой массив),
            foreach($this->attrs as $k => $v){ // Тогда мы проходимся по атрибутам в цикле
                $attrs .= " $k='$v' "; // Мы складываем их в строку по ключу и значению
            }
        }
        echo "<{$this->container} class='{$this->class}' $attrs>"; // Берем контейнер (у нас это тег "ul"), сюда будет подставлен класс "{$this->class}" который мы передали и будет добавлена строка атрибутов
        echo $this->prepend; // Может что-то выводится перед пунктом меню (потребуется в админке)
        echo $this->menuHtml; // Выводится само меню
        echo "</{$this->container}>"; // Закрыватся тег (у нас "ul")
    }

    protected function getTree(){ // Получаем из массива категорий дерево методом "getTree"
        $tree = []; // Метод из обычного массива (возвращает метод "R::getAssoc" RedBeanPHP строим дерево
        $data = $this->data;
        foreach ($data as $id=>&$node) {
            if (!$node['parent_id']){
                $tree[$id] = &$node;
            } else {
                $data[$node['parent_id']]['children'][$id] = &$node;
            }
        }
        return $tree;

    }

    protected function getMenuHtml($tree, $tab = ''){ // Из дерева меню нам нужно сделать верстку методом "getMenuHtml". Принимает два аргумента - "$tree" (изначальное дерево) и "$tab = ''" (разделитель, нам потребуется для админки)
        $str = '';
        foreach($tree as $id => $category){ // Цикл проходит по дереву, берет $id и саму категорию $category
            $str .= $this->catToTemplate($category, $tab, $id); // Вызывает метод "catToTemplate", который каждый конкретный пункт складывает с нужной версткой в строку
        }
        return $str; // которую мы возвращаем в итоге
    }

    protected function catToTemplate($category, $tab, $id){ // Вызывает метод "catToTemplate", который каждый конкретный пункт складывает с нужной версткой в строку
        ob_start(); // Включает буферизацию вывода (не было вывода на экран)
        require $this->tpl; // Подключает шаблон "menu_tpl.php"
        return ob_get_clean(); // Получаем из буфера нужные данные

    }



}